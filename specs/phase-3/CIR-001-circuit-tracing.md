# CIR-001: Circuit Tracing

| Field | Value |
|-------|-------|
| **Spec ID** | CIR-001 |
| **Phase** | 3 - Dynamic Hierarchy |
| **Status** | Draft |
| **Package** | `@horus/frontend`, `@horus/backend` |

## Summary

Circuit tracing reveals **why** text was generated by showing attribution paths through the feature graph. When users ask "Why did this word appear?", the system shows which features contributed to that output, enabling discovery of causal relationships and conversion of circuits into steering groups.

This implements "Discovery Mode" from the master plan - making the invisible visible.

## Requirements

### REQ-1: Circuit Trace Request

```typescript
interface CircuitTraceRequest {
  text: string;              // Input text to trace
  targetToken?: string;      // Specific token to explain (optional)
  maxDepth?: number;         // Attribution depth (default: 3)
  minContribution?: number;  // Minimum contribution threshold (default: 0.1)
}

interface CircuitTraceResponse {
  graph: AttributionGraph;
  metadata: {
    modelId: string;
    inputTokens: string[];
    targetToken?: string;
    computeTimeMs: number;
    cached: boolean;
  };
}

interface AttributionGraph {
  nodes: AttributionNode[];
  edges: AttributionEdge[];
}

interface AttributionNode {
  id: string;
  type: 'input' | 'feature' | 'output';

  // For features
  featureId?: string;
  layer?: number;
  index?: number;
  label?: string;

  // For tokens
  token?: string;
  position?: number;

  // Attribution
  contribution: number;      // How much this node contributed (0-1)
  activation?: number;       // Raw activation value
}

interface AttributionEdge {
  source: string;            // Node ID
  target: string;            // Node ID
  weight: number;            // Edge contribution (0-1)
}
```

**Acceptance Criteria:**
- [ ] Request structure compatible with Neuronpedia graph API
- [ ] Response includes full attribution graph
- [ ] Optional target token for focused tracing
- [ ] Configurable depth and threshold

### REQ-2: Backend Circuit Proxy

Proxy Neuronpedia's `/api/graph/generate` with retry logic.

```typescript
// packages/backend/src/routes/circuits.ts

const circuitsRoutes = new Hono()
  .post('/trace',
    zValidator('json', CircuitTraceRequestSchema),
    rateLimit({ limit: 20, window: 60 }),  // 20/min
    async (c) => {
      const request = c.req.valid('json');

      // Check cache first
      const cacheKey = hashRequest(request);
      const cached = await circuitCache.get(cacheKey);
      if (cached) {
        return c.json({ ...cached, metadata: { ...cached.metadata, cached: true } });
      }

      // Call Neuronpedia with retry
      const response = await retryWithBackoff(
        () => neuronpedia.generateGraph({
          modelId: 'gemma-2-2b',
          prompt: request.text,
          maxTokens: 64,  // Neuronpedia limit
        }),
        {
          maxRetries: 3,
          initialDelay: 1000,
          maxDelay: 10000,
          shouldRetry: (error) => error.status === 503,
        }
      );

      // Cache successful responses (1 hour)
      await circuitCache.set(cacheKey, response, 3600);

      return c.json(response);
    }
  );
```

**Error Handling:**
- 503 (GPU busy): Retry with exponential backoff
- 429 (rate limited): Return error with retry time
- Timeout: Return partial results if available

**Acceptance Criteria:**
- [ ] Endpoint proxies Neuronpedia graph API
- [ ] Retry logic for 503 errors
- [ ] Response cached for 1 hour
- [ ] Clear error messages for failures

### REQ-3: Circuit Panel UI

Display attribution graph in dedicated panel.

```typescript
// packages/frontend/src/components/panels/CircuitPanel.tsx

interface CircuitPanelProps {
  isOpen: boolean;
  onClose: () => void;
  selectedText?: string;
}

function CircuitPanel({ isOpen, selectedText }: CircuitPanelProps) {
  const [circuit, setCircuit] = useState<AttributionGraph | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const traceCircuit = async () => {
    if (!selectedText) return;

    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/circuits/trace', {
        method: 'POST',
        body: JSON.stringify({ text: selectedText }),
      });

      if (!response.ok) {
        throw new Error(await response.text());
      }

      setCircuit(await response.json());
    } catch (e) {
      setError(e.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Panel title="Circuit Trace" isOpen={isOpen}>
      {/* Input section */}
      <TextInput
        value={selectedText}
        onChange={setSelectedText}
        placeholder="Enter text to trace..."
      />
      <Button onClick={traceCircuit} disabled={loading}>
        {loading ? 'Tracing...' : 'Trace Circuit'}
      </Button>

      {/* Error state */}
      {error && <ErrorMessage message={error} onRetry={traceCircuit} />}

      {/* Graph visualization */}
      {circuit && (
        <CircuitGraph
          graph={circuit.graph}
          onNodeClick={handleNodeClick}
          onNodeHover={handleNodeHover}
        />
      )}
    </Panel>
  );
}
```

**Acceptance Criteria:**
- [ ] Panel opens from text selection or button
- [ ] Loading state during trace
- [ ] Error state with retry option
- [ ] Graph renders when trace completes

### REQ-4: Circuit Graph Visualization

Render attribution graph as interactive 2D diagram.

```typescript
// packages/frontend/src/components/circuit/CircuitGraph.tsx

interface CircuitGraphProps {
  graph: AttributionGraph;
  onNodeClick: (nodeId: string) => void;
  onNodeHover: (nodeId: string | null) => void;
}

function CircuitGraph({ graph, onNodeClick, onNodeHover }: CircuitGraphProps) {
  // Layout: input tokens on left, layers in middle, output on right
  const layout = useMemo(() => computeLayeredLayout(graph), [graph]);

  return (
    <svg className="circuit-graph" viewBox={layout.viewBox}>
      {/* Edges */}
      {graph.edges.map(edge => (
        <CircuitEdge
          key={`${edge.source}-${edge.target}`}
          edge={edge}
          sourcePos={layout.positions[edge.source]}
          targetPos={layout.positions[edge.target]}
        />
      ))}

      {/* Nodes */}
      {graph.nodes.map(node => (
        <CircuitNode
          key={node.id}
          node={node}
          position={layout.positions[node.id]}
          onClick={() => onNodeClick(node.id)}
          onHover={(hovering) => onNodeHover(hovering ? node.id : null)}
        />
      ))}
    </svg>
  );
}

function CircuitNode({ node, position, onClick, onHover }) {
  const color = node.type === 'input' ? '#4a9eff' :
                node.type === 'output' ? '#ff6b6b' :
                `hsl(45, ${node.contribution * 100}%, ${40 + node.contribution * 30}%)`;

  return (
    <g
      transform={`translate(${position.x}, ${position.y})`}
      onClick={onClick}
      onMouseEnter={() => onHover(true)}
      onMouseLeave={() => onHover(false)}
      className="circuit-node"
    >
      <circle
        r={10 + node.contribution * 20}
        fill={color}
        stroke={node.contribution > 0.5 ? '#ffd700' : '#666'}
        strokeWidth={2}
      />
      <text dy="30" textAnchor="middle" className="node-label">
        {node.label || node.token || `#${node.index}`}
      </text>
    </g>
  );
}
```

**Layout Algorithm:**
- Input tokens: Left column
- Features by layer: Middle columns (layer 0 → layer 25)
- Output token(s): Right column
- Dagre.js or custom force-directed layout

**Acceptance Criteria:**
- [ ] Clear left-to-right flow visualization
- [ ] Node size reflects contribution
- [ ] Edge thickness reflects weight
- [ ] Hover shows detailed info
- [ ] Click highlights in main graph

### REQ-5: Main Graph Integration

Clicking circuit node highlights corresponding feature in main 3D graph.

```typescript
// In CircuitPanel
const handleNodeClick = (nodeId: string) => {
  const node = circuit.graph.nodes.find(n => n.id === nodeId);

  if (node?.featureId) {
    // Highlight in main graph
    highlightNodes([node.featureId]);

    // Optionally fly camera to feature
    focusOnNode(node.featureId);

    // Show in details panel
    selectNodes([node.featureId]);
  }
};

const handleNodeHover = (nodeId: string | null) => {
  if (nodeId) {
    const node = circuit.graph.nodes.find(n => n.id === nodeId);
    if (node?.featureId) {
      setHoveredNode(node.featureId);
    }
  } else {
    setHoveredNode(null);
  }
};
```

**Acceptance Criteria:**
- [ ] Hover in circuit → hover highlight in main graph
- [ ] Click in circuit → select in main graph
- [ ] Camera optionally flies to feature
- [ ] Bidirectional: select in main graph → highlight in circuit

### REQ-6: Circuit to Steering Group Conversion

Convert discovered circuit into a steering group.

```typescript
interface CircuitToGroupOptions {
  name: string;
  minContribution: number;     // Only include features above threshold
  normalizeWeights: boolean;   // Scale weights to 0-1
}

function circuitToSteeringGroup(
  circuit: AttributionGraph,
  options: CircuitToGroupOptions
): SteeringGroup {
  // Extract features with sufficient contribution
  const featureNodes = circuit.nodes.filter(
    n => n.type === 'feature' && n.contribution >= options.minContribution
  );

  // Build feature map
  const features = new Map<string, number>();
  for (const node of featureNodes) {
    const weight = options.normalizeWeights
      ? node.contribution / Math.max(...featureNodes.map(n => n.contribution))
      : node.contribution;
    features.set(node.featureId!, weight);
  }

  // Compute centroid
  const positions = featureNodes.map(n => getFeaturePosition(n.featureId!));
  const centroid = computeCentroid(positions);
  const radius = computeRadius(positions, centroid);

  return {
    id: `circuit-${Date.now()}`,
    label: options.name,
    features,
    position: centroid,
    radius,
    source: 'circuit',
    strength: 0,
    isActive: false,
    createdAt: Date.now(),
  };
}
```

**UI:**
```
┌─────────────────────────────────────┐
│ Create Steering Group from Circuit  │
├─────────────────────────────────────┤
│ Name: [formal_tone_circuit    ]     │
│                                     │
│ Include features with contribution: │
│ ○ > 10%  ● > 25%  ○ > 50%          │
│                                     │
│ Features included: 12               │
│                                     │
│ [Cancel]              [Create Group]│
└─────────────────────────────────────┘
```

**Acceptance Criteria:**
- [ ] Button to convert circuit to group
- [ ] Configurable contribution threshold
- [ ] Group appears in mixer panel
- [ ] Group position matches circuit features

## Technical Notes

### Neuronpedia Graph API

```typescript
// Request format
POST /api/graph/generate
{
  "modelId": "gemma-2-2b",
  "prompt": "The quick brown fox",
  "maxTokens": 64,           // Hard limit
  "slugs": ["12-gemmascope-res-16k"]  // Optional: specific layers
}

// Response includes attribution data
// May return 503 if GPUs busy - implement retry
```

### Caching Strategy

- Cache by hash of (text + options)
- TTL: 1 hour (circuits unlikely to change)
- Max cache size: 100 circuits
- LRU eviction

### Performance Considerations

- Graph API can be slow (5-30 seconds)
- Show progress indicator
- Consider WebSocket for long-polling
- Pre-fetch for selected text on hover (speculative)

## Dependencies

- [LIVE-001](LIVE-001-click-to-steer.md) - Highlight integration
- [GRP-001](GRP-001-steering-groups.md) - Circuit to group conversion
- [API-001](../phase-1/API-001-neuronpedia.md) - Neuronpedia client
- [GRAPH-003](../phase-1/GRAPH-003-renderer.md) - Main graph highlighting

## Open Questions

1. Should circuit tracing be triggered automatically after generation?
2. How to handle very large circuits (>100 nodes)?
3. Should circuits be saveable/shareable?
4. Integration with trajectory view - trace per-token?

## Changelog

| Date | Changes |
|------|---------|
| 2025-01-11 | Initial draft |
